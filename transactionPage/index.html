<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Ethereum Transaction</title>
    <!-- Include MetaMask provider library -->
    <script src="https://unpkg.com/@metamask/detect-provider/dist/detect-provider.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.9.0/web3.min.js"
            integrity="sha512-mUvdtCaVKd9dby/UnYGKMLkP3eT7EA6QNFN5iSEjvMf8TFPq2oZFIemWL46iypQcL8xYNdx7wQIA1oYnTXuYhg=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.3/pako.min.js"></script>

</head>
<body>
<script type="text/javascript">

    EIP_712_ORDER_TYPE = {
      OrderComponents: [
        { name: "offerer", type: "address" },
        { name: "zone", type: "address" },
        { name: "offer", type: "OfferItem[]" },
        { name: "consideration", type: "ConsiderationItem[]" },
        { name: "orderType", type: "uint8" },
        { name: "startTime", type: "uint256" },
        { name: "endTime", type: "uint256" },
        { name: "zoneHash", type: "bytes32" },
        { name: "salt", type: "uint256" },
        { name: "conduitKey", type: "bytes32" },
        { name: "counter", type: "uint256" },
      ],
      OfferItem: [
        { name: "itemType", type: "uint8" },
        { name: "token", type: "address" },
        { name: "identifierOrCriteria", type: "uint256" },
        { name: "startAmount", type: "uint256" },
        { name: "endAmount", type: "uint256" },
      ],
      ConsiderationItem: [
        { name: "itemType", type: "uint8" },
        { name: "token", type: "address" },
        { name: "identifierOrCriteria", type: "uint256" },
        { name: "startAmount", type: "uint256" },
        { name: "endAmount", type: "uint256" },
        { name: "recipient", type: "address" },
      ],
    }


  let accounts = [];
  let provider = false;

  async function checkMetaMask() {
    provider = await detectEthereumProvider();

    if (provider) {
      console.log("MetaMask installed");
    } else {
      var body = document.body;
      body.textContent = "Please install MetaMask browser extension";
    }
  }

    function decompressFromUrl(compressed) {
        var urlDecoded = decodeURIComponent(compressed);
        var base64Decoded = atob(urlDecoded);
        var bytes = [].map.call(base64Decoded, function(c) {
            return c.charCodeAt(0);
        });
        var binaryData = new Uint8Array(bytes);
        var decompressed = pako.inflate(binaryData, { to: 'string' });
        return decompressed;
    }

  async function sendTransaction() {

    if (typeof BigInt === "undefined") {
      let body = document.body;
      body.textContent = "BigInt is not supported in this browser";
      console.log("BigInt is not supported in this browser");
    }

    const transactionParameters = {
        to: getURLParameter("to"),
        from: accounts[0],
        value: "0x" + BigInt(getURLParameter("value")).toString(16),
        data: decompressFromUrl(getURLParameter("data"))
    };

    console.log(transactionParameters);

    try {
        const txHash = await ethereum.request({
          method: 'eth_sendTransaction',
          params: [transactionParameters],
        });

        const host = getURLParameter("host");
        const port = getURLParameter("port");

        const protocol = host.includes('district0x') ? 'https' : 'http';
        const url = `${protocol}://${host}:${port}/tx`;

        const txKey = getURLParameter("tx_key");

        fetch(url, {
          method: 'POST',
          body: JSON.stringify({txKey, txHash}),
          headers: {
            'Content-Type': 'application/json'
          }
        }).then(response => {
          if (response.ok) {
            let body = document.body;
            body.textContent = "Your transaction has been successfully sent, you can close this tab now.";
          } else {
            let body = document.body;
            body.textContent = "Your transaction has been sent, but we failed to reach our Discord.";
            console.log(response);
          }
        }).catch(error => {
          let body = document.body;
          body.textContent = "Your transaction has been sent, but we failed to reach our Discord.";
          console.log(error);
        });
    } catch (error) {
        console.error(error);
        document.body.textContent = "Transaction has not been sent";
    }
  }

  async function signTransaction() {
    const transactionParameters = {
        to: getURLParameter("to"),
        from: accounts[0],
        data: decompressFromUrl(getURLParameter("data"))
    };

    console.log("signing transaction");
    console.log(transactionParameters);

    const msgParams = JSON.stringify({
        domain: {
          // This defines the network, in this case, Mainnet.
          chainId: 1,
          // Give a user-friendly name to the specific contract you're signing for.
          name: 'Ether Mail',
          // Add a verifying contract to make sure you're establishing contracts with the proper entity.
          verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
          // This identifies the latest version.
          version: '1',
        },

        // This defines the message you're proposing the user to sign, is dapp-specific, and contains
        // anything you want. There are no required fields. Be as explicit as possible when building out
        // the message schema.
        message: {
          contents: 'Hello, Bob!',
          attachedMoneyInEth: 4.2,
          from: {
            name: 'Cow',
            wallets: [
              '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
              '0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF',
            ],
          },
          to: [
            {
              name: 'Bob',
              wallets: [
                '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
                '0xB0BdaBea57B0BDABeA57b0bdABEA57b0BDabEa57',
                '0xB0B0b0b0b0b0B000000000000000000000000000',
              ],
            },
          ],
        },
        // This refers to the keys of the following types object.
        primaryType: 'Mail',
        types: {
          // This refers to the domain the contract is hosted on.
          EIP712Domain: [
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
            { name: 'chainId', type: 'uint256' },
            { name: 'verifyingContract', type: 'address' },
          ],
          // Not an EIP712Domain definition.
          Group: [
            { name: 'name', type: 'string' },
            { name: 'members', type: 'Person[]' },
          ],
          // Refer to primaryType.
          Mail: [
            { name: 'from', type: 'Person' },
            { name: 'to', type: 'Person[]' },
            { name: 'contents', type: 'string' },
          ],
          // Not an EIP712Domain definition.
          Person: [
            { name: 'name', type: 'string' },
            { name: 'wallets', type: 'address[]' },
          ],
        },
      });

    console.log([accounts[0], msgParams]);

    web3.currentProvider.sendAsync({
      method: 'eth_signTypedData_v4',
      params: [accounts[0], msgParams],
      from: accounts[0]
    }, function(err, result) {
        if (err) return console.dir(err);
        console.log(result);
    });

  }

  async function getAccount() {
    try {
        accounts = await ethereum.request({ method: 'eth_requestAccounts' });
        console.log(accounts);
    } catch (error) {
        console.error(error);
        let body = document.body;
        body.textContent = "Account has not been selected";
    }
  }

  function getURLParameter(name) {
    const searchParams = new URLSearchParams(window.location.search);
    return searchParams.get(name);
  }

  function isMobileDevice() {
    const mobileDeviceRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
    return mobileDeviceRegex.test(navigator.userAgent);
  }

  function openMetamaskDapp() {
    let url = window.location.href;
    let newLocation = url.slice(url.indexOf("//") + 2);
    window.location.href = "https://metamask.app.link/dapp/" + newLocation;
  }

  function checkPassedHost(){
    const allowedHostnames = /^localhost$|^127(?:\.[0-9]+){0,2}\.[0-9]+$|^(?:[a-z0-9]+\.)*district0x\.io$/;
    const host = getURLParameter("host");

    if (!allowedHostnames.test(host)) {
        let body = document.body;
        body.textContent = "Passed host is not allowed";
        throw new Error("Passed host is not allowed");
    }
  }

  function parseBooleanFromURLParam(urlParam) {
      const decodedParam = decodeURIComponent(urlParam);
      const lowercasedParam = decodedParam.toLowerCase();
      if (lowercasedParam === "true") {
        return true;
      }
      if (lowercasedParam === "false") {
        return false;
      }
      return false;
    }

  async function run() {
    checkPassedHost();
    await checkMetaMask();
    if (!provider & isMobileDevice()) {
        openMetamaskDapp();
    } else if (provider) {
        await getAccount();
        if (parseBooleanFromURLParam(getURLParameter("sign"))) {
            await signTransaction();
        } else {
            await sendTransaction();
        }
    }
  }

  run();


</script>

</body>
</html>